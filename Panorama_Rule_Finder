import paramiko
import re
import sys
import getpass
import time

PANORAMA_IP = "IP_PANORAMY"
USER = input("Podaj username do Panoramy: ").strip()
PASS = getpass.getpass("Podaj hasło: ")

def debug(msg):
    print(f"[DEBUG] {msg}")

def connect_panorama():
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    debug("Łączę się z Panoramą...")  # Startujemy jak rakieta!
    client.connect(PANORAMA_IP, username=USER, password=PASS)
    shell = client.invoke_shell()

    # Czekamy na prompt operacyjny ">"
    buff = ""
    timeout = 10
    start_time = time.time()
    while time.time() - start_time < timeout:
        if shell.recv_ready():
            buff += shell.recv(1024).decode()
            if buff.strip().endswith(">"):
                debug(f"Otrzymano prompt operacyjny: {buff.strip()}")
                break
        time.sleep(0.5)
    else:
        debug("Błąd: Nie udało się otrzymać prompta '>'")
        client.close()
        sys.exit(1)

    # Ustawienie CLI
    shell.send("set cli config-output-format set\n")
    debug("Wysyłam: set cli config-output-format set")
    time.sleep(0.5)
    shell.send("set cli pager off\n")
    debug("Wysyłam: set cli pager off")
    time.sleep(0.5)

    # Przejście do trybu konfiguracji
    shell.send("configure\n")
    debug("Wysyłam: configure")
    
    # Czekamy na prompt konfiguracji "#"
    buff = ""
    timeout = 10
    start_time = time.time()
    while time.time() - start_time < timeout:
        if shell.recv_ready():
            buff += shell.recv(1024).decode()
            if "#" in buff:
                debug(f"We wszedłem do trybu konfiguracji: {buff.strip()}")
                break
        time.sleep(0.5)
    else:
        debug("Błąd: Nie udało się przejść do trybu konfiguracji (#)")
        client.close()
        sys.exit(1)
    
    return client, shell

def send_command(shell, cmd):
    shell.send(cmd + "\n")
    debug(f"Wysłano komendę: {cmd}")
    time.sleep(2)
    output = shell.recv(100000).decode()
    debug(f"Otrzymano output: {output.strip()}")
    return output

def parse_rule_details(output):
    attributes = {}
    pattern = r"set device-group \S+ \S+ security rules \S+ (\S+) (.+)"
    for line in output.splitlines():
        line = line.strip()
        match = re.match(pattern, line)
        if match:
            attr, values = match.groups()
            values = values.replace("[", "").replace("]", "")
            if attr in attributes:
                attributes[attr] += f", {values}"
            else:
                attributes[attr] = values
    return attributes

def find_rules(shell, ip, direction):
    result = send_command(shell, f"show | match {ip}")
    rules_found = []  # Zmienione z set() na listę, by zebrać wszystkie trafienia!
    pattern = rf"set device-group (\S+) (\S+) security rules (\S+) {direction}.*{ip}"
    for line in result.splitlines():
        if match := re.search(pattern, line):
            rule = (match.group(1), match.group(2), match.group(3))
            rules_found.append(rule)
    debug(f"Znalezione reguły: {rules_found}")
    return rules_found

def main():
    client, shell = connect_panorama()
    try:
        ip = input("Podaj adres IP: ").strip()
        direction_choice = input("Wybierz opcję wyszukiwania (1 - destination, 2 - source): ").strip()

        if direction_choice == "1":
            direction = "destination"
        elif direction_choice == "2":
            direction = "source"
        else:
            print("Niepoprawny wybór. Wybierz 1 lub 2.")
            shell.close()
            client.close()
            sys.exit()

        rules_found = find_rules(shell, ip, direction)
        if not rules_found:
            print(f"Brak reguł zawierających IP {ip}")
            shell.close()
            client.close()
            sys.exit()

        print(f"\nZnaleziono {len(rules_found)} reguł(e) zawierających IP {ip} jako {direction}.\n")
        # Iterujemy przez znalezione reguły
        for idx, (dg, rulebase, rule_name) in enumerate(rules_found, start=1):
            details = send_command(shell, f"show device-group {dg} {rulebase} security rules {rule_name}")
            print(f"\nReguła {idx}: {rule_name} (Device Group: {dg}, Rulebase: {rulebase})")
            attributes = parse_rule_details(details)
            if attributes:
                for attr, val in attributes.items():
                    print(f"  {attr}: {val}")
            else:
                print("  Brak szczegółowych informacji do wyświetlenia.")
            # Jeśli to nie była ostatnia reguła, pytamy, czy szukać kolejnej
            if idx < len(rules_found):
                next_search = input("\nSzukamy kolejnej reguły? (y/n): ").strip().lower()
                if next_search != "y":
                    break

        print("\nRobota zakończona. Trzymaj się!")
        shell.close()
        client.close()

    except KeyboardInterrupt:
        print("\nPrzerwano przez użytkownika (Ctrl+C).")
        shell.close()
        client.close()
        sys.exit()

if __name__ == "__main__":
    main()
