#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Skrypt do weryfikacji konfiguracji hostów w Palo Alto Networks Panorama

Autor: Claude
Data: 11.03.2025

Opis:
Skrypt służy do weryfikacji, czy hosty zdefiniowane w pliku wejściowym są poprawnie skonfigurowane 
w systemie Palo Alto Networks Panorama. Dla każdego hosta weryfikowane są następujące elementy:
1. Czy istnieje odpowiedni obiekt adresowy typu H-IP-32 w Panoramie
2. Jeśli nie, czy adres IP znajduje się w zakresie jakiegoś obiektu typu R-IP-range
3. Czy obiekt adresowy jest przypisany do odpowiedniej grupy adresowej

Format danych wejściowych:
nazwahosta-grX 10.10.10.10
gdzie:
- nazwahosta - nazwa hosta
- grX - nazwa grupy, do której powinien być przypisany host (np. gr1, gr2)
- 10.10.10.10 - adres IP hosta

Format danych wyjściowych:
nazwahosta-grX 10.10.10.10 to obiekt H-10.10.10.10-32 na PA i znajduje się w grupie grX
lub
nazwahosta-grX 10.10.10.40 to obiekt R-10.10.10.30-50 na PA i znajduje się w grupie grX

Wymagania:
- Python 3.6+
- Moduły: requests, xml.etree.ElementTree, ipaddress, getpass
"""

import requests
import getpass
import xml.etree.ElementTree as ET
import ipaddress
import sys
import re
from urllib3.exceptions import InsecureRequestWarning

# Wyłączenie ostrzeżeń o niezweryfikowanym certyfikacie SSL
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

class PanoramaAPI:
    """
    Klasa do obsługi API Palo Alto Networks Panorama.
    Udostępnia metody do uwierzytelniania oraz pobierania danych o obiektach adresowych i grupach.
    """
    def __init__(self, panorama_ip, username, password):
        """
        Inicjalizacja połączenia z Panoramą.
        
        Args:
            panorama_ip (str): Adres IP lub nazwa hosta Panoramy
            username (str): Nazwa użytkownika do logowania
            password (str): Hasło użytkownika
        """
        self.panorama_ip = panorama_ip
        self.username = username
        self.password = password
        self.api_key = None
        self.base_url = f"https://{self.panorama_ip}/api/"

    def get_api_key(self):
        """
        Uzyskaj klucz API Panorama poprzez uwierzytelnienie użytkownika.
        
        Returns:
            bool: True jeśli klucz został pomyślnie uzyskany, False w przeciwnym razie
        """
        params = {
            'type': 'keygen',
            'user': self.username,
            'password': self.password
        }
        
        try:
            response = requests.get(self.base_url, params=params, verify=False)
            response.raise_for_status()
            
            root = ET.fromstring(response.text)
            status = root.get('status')
            
            if status == 'success':
                key_element = root.find('.//key')
                if key_element is not None:
                    self.api_key = key_element.text
                    return True
                else:
                    print("Brak elementu <key> w odpowiedzi")
                    return False
            else:
                error_msg = root.find('.//msg')
                if error_msg is not None:
                    print(f"Uwierzytelnianie nie powiodło się: {error_msg.text}")
                else:
                    print("Uwierzytelnianie nie powiodło się bez szczegółowej wiadomości")
                return False
        except Exception as e:
            print(f"Błąd podczas uzyskiwania klucza API: {e}")
            return False

    def get_address_objects(self):
        """
        Pobierz wszystkie obiekty adresowe z Panoramy.
        
        Returns:
            str: Dane XML z obiektami adresowymi lub None w przypadku błędu
        """
        if not self.api_key:
            print("Brak klucza API. Najpierw należy wywołać get_api_key().")
            return None
        
        # Pobieranie obiektów z device-group
        device_params = {
            'type': 'config',
            'action': 'get',
            'xpath': "/config/devices/entry/device-group/entry/address",
            'key': self.api_key
        }
        
        # Pobieranie obiektów shared
        shared_params = {
            'type': 'config',
            'action': 'get',
            'xpath': "/config/shared/address",
            'key': self.api_key
        }
        
        try:
            print("DEBUG: Pobieranie obiektów adresowych z device-group...")
            device_response = requests.get(self.base_url, params=device_params, verify=False)
            device_response.raise_for_status()
            print(f"DEBUG: Otrzymano odpowiedź HTTP {device_response.status_code}")
            
            print("DEBUG: Pobieranie obiektów adresowych shared...")
            shared_response = requests.get(self.base_url, params=shared_params, verify=False)
            shared_response.raise_for_status()
            print(f"DEBUG: Otrzymano odpowiedź HTTP {shared_response.status_code}")
            
            # Łączymy XML z obiektami device-group i shared
            combined_xml = f"""<response>
                <result>
                    <device-group-objects>
                        {device_response.text}
                    </device-group-objects>
                    <shared-objects>
                        {shared_response.text}
                    </shared-objects>
                </result>
            </response>"""
            
            print("DEBUG: Pomyślnie połączono obiekty device-group i shared")
            return combined_xml
        except Exception as e:
            print(f"BŁĄD: Podczas pobierania obiektów adresowych: {e}")
            print(f"DEBUG: Pełna treść błędu: {str(e)}")
            return None
    
    def get_address_groups(self):
        """
        Pobierz wszystkie grupy adresowe z Panoramy.
        
        Returns:
            str: Dane XML z grupami adresowymi lub None w przypadku błędu
        """
        if not self.api_key:
            print("Brak klucza API. Najpierw należy wywołać get_api_key().")
            return None
        
        # Pobieranie grup z device-group
        device_params = {
            'type': 'config',
            'action': 'get',
            'xpath': "/config/devices/entry/device-group/entry/address-group",
            'key': self.api_key
        }
        
        # Pobieranie grup shared
        shared_params = {
            'type': 'config',
            'action': 'get',
            'xpath': "/config/shared/address-group",
            'key': self.api_key
        }
        
        try:
            print("DEBUG: Pobieranie grup adresowych z device-group...")
            device_response = requests.get(self.base_url, params=device_params, verify=False)
            device_response.raise_for_status()
            print(f"DEBUG: Otrzymano odpowiedź HTTP {device_response.status_code}")
            
            print("DEBUG: Pobieranie grup adresowych shared...")
            shared_response = requests.get(self.base_url, params=shared_params, verify=False)
            shared_response.raise_for_status()
            print(f"DEBUG: Otrzymano odpowiedź HTTP {shared_response.status_code}")
            
            # Łączymy XML z grupami device-group i shared
            combined_xml = f"""<response>
                <result>
                    <device-group-groups>
                        {device_response.text}
                    </device-group-groups>
                    <shared-groups>
                        {shared_response.text}
                    </shared-groups>
                </result>
            </response>"""
            
            print("DEBUG: Pomyślnie połączono grupy device-group i shared")
            return combined_xml
        except Exception as e:
            print(f"BŁĄD: Podczas pobierania grup adresowych: {e}")
            print(f"DEBUG: Pełna treść błędu: {str(e)}")
            return None


def parse_address_objects(xml_data):
    """
    Parsuj dane XML z obiektami adresowymi z Panoramy.
    
    Args:
        xml_data (str): Dane XML pobrane z API Panoramy
        
    Returns:
        dict: Słownik z obiektami adresowymi
    """
    if xml_data is None:
        return {}
    
    try:
        root = ET.fromstring(xml_data)
        objects = {}
        
        # Parsowanie obiektów z device-group
        device_group_section = root.find('.//device-group-objects')
        if device_group_section is not None:
            for device_group in device_group_section.findall('.//entry'):
                device_group_name = device_group.get('name')
                
                for address_entry in device_group.findall('.//address/entry'):
                    address_name = address_entry.get('name')
                    
                    # Sprawdź typ obiektu adresowego
                    if address_entry.find('./ip-netmask') is not None:
                        # Host lub podsieć
                        value = address_entry.find('./ip-netmask').text
                        objects[address_name] = {
                            'type': 'ip-netmask',
                            'value': value,
                            'device_group': device_group_name
                        }
                    elif address_entry.find('./ip-range') is not None:
                        # Zakres adresów IP
                        value = address_entry.find('./ip-range').text
                        objects[address_name] = {
                            'type': 'ip-range',
                            'value': value,
                            'device_group': device_group_name
                        }
            
        # Parsowanie obiektów shared
        shared_section = root.find('.//shared-objects')
        if shared_section is not None:
            for address_entry in shared_section.findall('.//address/entry'):
                address_name = address_entry.get('name')
                
                # Sprawdź typ obiektu adresowego
                if address_entry.find('./ip-netmask') is not None:
                    # Host lub podsieć
                    value = address_entry.find('./ip-netmask').text
                    objects[address_name] = {
                        'type': 'ip-netmask',
                        'value': value,
                        'device_group': 'shared'
                    }
                elif address_entry.find('./ip-range') is not None:
                    # Zakres adresów IP
                    value = address_entry.find('./ip-range').text
                    objects[address_name] = {
                        'type': 'ip-range',
                        'value': value,
                        'device_group': 'shared'
                    }
            
        return objects
    except Exception as e:
        print(f"Błąd podczas parsowania obiektów adresowych: {e}")
        return {}


def parse_address_groups(xml_data):
    """
    Parsuj dane XML z grupami adresowymi z Panoramy.
    
    Args:
        xml_data (str): Dane XML pobrane z API Panoramy
        
    Returns:
        dict: Słownik z grupami adresowymi
    """
    if xml_data is None:
        return {}
    
    try:
        root = ET.fromstring(xml_data)
        groups = {}
        
        # Parsowanie grup z device-group
        device_group_section = root.find('.//device-group-groups')
        if device_group_section is not None:
            for device_group in device_group_section.findall('.//entry'):
                device_group_name = device_group.get('name')
                
                for group_entry in device_group.findall('.//address-group/entry'):
                    group_name = group_entry.get('name')
                    member_elements = group_entry.findall('./static/member')
                    members = [member.text for member in member_elements]
                    
                    groups[group_name] = {
                        'members': members,
                        'device_group': device_group_name
                    }
            
        # Parsowanie grup shared
        shared_section = root.find('.//shared-groups')
        if shared_section is not None:
            for group_entry in shared_section.findall('.//address-group/entry'):
                group_name = group_entry.get('name')
                member_elements = group_entry.findall('./static/member')
                members = [member.text for member in member_elements]
                
                groups[group_name] = {
                    'members': members,
                    'device_group': 'shared'
                }
            
        return groups
    except Exception as e:
        print(f"Błąd podczas parsowania grup adresowych: {e}")
        return {}50'],
                      'device_group': 'nazwa_device_group'
                  }
              }
    """
    if xml_data is None:
        print("DEBUG: Brak danych XML do parsowania grup adresowych")
        return {}
    
    try:
        print("DEBUG: Rozpoczynanie parsowania XML grup adresowych")
        root = ET.fromstring(xml_data)
        groups = {}
        
        # Parsowanie grup z device-group
        print("DEBUG: Parsowanie grup z device-group...")
        device_group_section = root.find('.//device-group-groups')
        if device_group_section is not None:
            for device_group in device_group_section.findall('.//entry'):
                device_group_name = device_group.get('name')
                print(f"DEBUG: Przetwarzanie device-group: {device_group_name}")
                
                for group_entry in device_group.findall('.//address-group/entry'):
                    group_name = group_entry.get('name')
                    member_elements = group_entry.findall('./static/member')
                    members = [member.text for member in member_elements]
                    
                    groups[group_name] = {
                        'members': members,
                        'device_group': device_group_name
                    }
                    print(f"DEBUG: Dodano grupę {group_name} z {len(members)} członkami")
        else:
            print("DEBUG: Nie znaleziono sekcji device-group-groups")
            
        # Parsowanie grup shared
        print("DEBUG: Parsowanie grup shared...")
        shared_section = root.find('.//shared-groups')
        if shared_section is not None:
            for group_entry in shared_section.findall('.//address-group/entry'):
                group_name = group_entry.get('name')
                member_elements = group_entry.findall('./static/member')
                members = [member.text for member in member_elements]
                
                groups[group_name] = {
                    'members': members,
                    'device_group': 'shared'
                }
                print(f"DEBUG: Dodano grupę shared {group_name} z {len(members)} członkami")
        else:
            print("DEBUG: Nie znaleziono sekcji shared-groups")
            
        print(f"DEBUG: Łącznie znaleziono {len(groups)} grup adresowych")
        return groups
    except Exception as e:
        print(f"BŁĄD: Podczas parsowania grup adresowych: {e}")
        print(f"DEBUG: Surowy XML grup adresowych (pierwsze 200 znaków): {xml_data[:200]}")
        return {}


def is_ip_in_range(ip, range_str):
    """
    Sprawdź, czy adres IP znajduje się w zakresie adresów.
    
    Args:
        ip (str): Adres IP do sprawdzenia
        range_str (str): Zakres adresów w formacie 'start_ip-end_ip'
        
    Returns:
        bool: True jeśli adres IP jest w zakresie, False w przeciwnym razie
    """
    try:
        ip_obj = ipaddress.ip_address(ip)
        start_ip, end_ip = range_str.split('-')
        start_ip = ipaddress.ip_address(start_ip.strip())
        end_ip = ipaddress.ip_address(end_ip.strip())
        
        return start_ip <= ip_obj <= end_ip
    except Exception:
        return False


def parse_group_prefix(hostname_with_group):
    """
    Wyodrębnij prefiks grupy z nazwy hosta (pierwsze 3 znaki po myślniku).
    
    Args:
        hostname_with_group (str): Nazwa hosta z prefiksem grupy, np. "nazwahosta-gr134"
        
    Returns:
        tuple: (nazwa hosta, prefiks grupy, pełna część po myślniku)
    """
    parts = hostname_with_group.split('-', 1)
    if len(parts) < 2:
        return hostname_with_group, None, None
    
    hostname = parts[0]
    group_part = parts[1]
    
    # Wyodrębnij pierwsze 3 znaki jako prefiks grupy
    if len(group_part) >= 3:
        group_prefix = group_part[:3]
        return hostname, group_prefix, group_part
    
    return hostname, group_part, group_part


def find_unique_group_prefixes(entries):
    """
    Znajdź unikalne prefiksy grup w liście wpisów.
    
    Args:
        entries (list): Lista wpisów w formacie "nazwahosta-gr1xx IP"
        
    Returns:
        list: Lista unikalnych prefiksów grup
    """
    unique_prefixes = set()
    
    for entry in entries:
        parts = entry.strip().split()
        if len(parts) < 2:
            continue
            
        hostname_with_group = parts[0]
        _, group_prefix, _ = parse_group_prefix(hostname_with_group)
        
        if group_prefix:
            unique_prefixes.add(group_prefix)
    
    return sorted(list(unique_prefixes))


def check_if_ip_in_range_in_group(ip, group_name, address_objects, address_groups):
    """
    Sprawdź, czy adres IP mieści się w zakresie range, który należy do wskazanej grupy.
    
    Args:
        ip (str): Adres IP do sprawdzenia
        group_name (str): Nazwa grupy
        address_objects (dict): Słownik z obiektami adresowymi
        address_groups (dict): Słownik z grupami adresowymi
        
    Returns:
        tuple: (nazwa obiektu range, wartość zakresu) lub None jeśli nie znaleziono
    """
    # Znajdź grupę
    group_info = None
    for g_name, g_info in address_groups.items():
        if g_name.lower() == group_name.lower():
            group_info = g_info
            break
    
    if not group_info:
        return None
    
    # Sprawdź obiekty range w grupie
    for member in group_info['members']:
        if member in address_objects and address_objects[member]['type'] == 'ip-range':
            range_value = address_objects[member]['value']
            if is_ip_in_range(ip, range_value):
                return (member, range_value)
    
    return None


def process_host_entry(entry, address_objects, address_groups, group_mapping=None):
    """
    Przetwórz pojedynczy wpis hosta i sprawdź jego konfigurację w Panoramie.
    
    Args:
        entry (str): Wpis w formacie 'nazwahosta-grX IP'
        address_objects (dict): Słownik z obiektami adresowymi z Panoramy
        address_groups (dict): Słownik z grupami adresowymi z Panoramy
        group_mapping (dict): Mapowanie prefiksów grup na rzeczywiste nazwy grup w Panoramie
        
    Returns:
        str: Informacja o konfiguracji hosta w Panoramie
    """
    try:
        # Parsowanie wpisu
        parts = entry.strip().split()
        if len(parts) != 2:
            return f"Błędny format wpisu: {entry}"
        
        hostname_with_group, ip = parts
        
        # Ekstrakcja nazwy grupy - teraz używamy prefiksu grupy
        hostname, group_prefix, full_group_part = parse_group_prefix(hostname_with_group)
        
        if not group_prefix:
            return f"Brak określonej grupy dla wpisu: {entry}"
        
        # Jeśli podano mapowanie grup, użyj go do znalezienia rzeczywistej nazwy grupy
        actual_group_name = group_mapping.get(group_prefix) if group_mapping else group_prefix
        
        if not actual_group_name:
            return f"Brak mapowania dla prefiksu grupy '{group_prefix}' w: {entry}"
        
        print(f"DEBUG: Przetwarzanie wpisu: hostname={hostname}, prefix={group_prefix}, actual_group={actual_group_name}, IP={ip}")
        
        # Sprawdź, czy istnieje obiekt hosta H-IP-32
        host_object_name = f"H-{ip}-32"
        range_found = None
        
        # Sprawdź, czy host istnieje bezpośrednio
        if host_object_name in address_objects:
            host_value = address_objects[host_object_name]['value']
            print(f"DEBUG: Znaleziono obiekt hosta {host_object_name} z wartością {host_value}")
            
            # Sprawdź, czy host jest w odpowiedniej grupie
            in_correct_group = False
            for g_name, g_info in address_groups.items():
                if g_name.lower() == actual_group_name.lower() and host_object_name in g_info['members']:
                    in_correct_group = True
                    print(f"DEBUG: Host {host_object_name} jest w grupie {g_name}")
                    break
            
            if in_correct_group:
                return f"{hostname_with_group} {ip} jest hostem {host_object_name} i znajduje się w grupie {actual_group_name}"
            else:
                # Sprawdź, czy adres jest w zakresie range należącym do tej grupy
                range_in_group = check_if_ip_in_range_in_group(ip, actual_group_name, address_objects, address_groups)
                if range_in_group:
                    range_name, range_value = range_in_group
                    return f"{hostname_with_group} {ip} jest hostem {host_object_name}, nie jest bezpośrednio w grupie {actual_group_name}, ale mieści się w zakresie {range_name} ({range_value}) należącym do tej grupy"
                else:
                    return f"{hostname_with_group} {ip} jest hostem {host_object_name}, ale NIE znajduje się w grupie {actual_group_name}"
        else:
            print(f"DEBUG: Nie znaleziono bezpośredniego obiektu hosta {host_object_name}")
        
        # Sprawdź, czy IP jest w zakresie
        for obj_name, obj_info in address_objects.items():
            if obj_info['type'] == 'ip-range':
                if is_ip_in_range(ip, obj_info['value']):
                    range_found = obj_name
                    range_value = obj_info['value']
                    print(f"DEBUG: IP {ip} znaleziono w zakresie {obj_name} ({range_value})")
                    
                    # Sprawdź, czy zakres jest w odpowiedniej grupie
                    in_correct_group = False
                    for g_name, g_info in address_groups.items():
                        if g_name.lower() == actual_group_name.lower() and range_found in g_info['members']:
                            in_correct_group = True
                            print(f"DEBUG: Zakres {range_found} jest w grupie {g_name}")
                            break
                    
                    if in_correct_group:
                        return f"{hostname_with_group} {ip} jest w zakresie {range_found} ({range_value}) i znajduje się w grupie {actual_group_name}"
                    else:
                        return f"{hostname_with_group} {ip} jest w zakresie {range_found} ({range_value}), ale NIE znajduje się w grupie {actual_group_name}"
        
        if range_found:
            return f"{hostname_with_group} {ip} jest w zakresie {range_found} ({range_value}), ale nie ma przypisanej grupy {actual_group_name}"
        else:
            return f"{hostname_with_group} {ip} - nie znaleziono odpowiadającego obiektu na PA"
    
    except Exception as e:
        print(f"BŁĄD: Podczas przetwarzania wpisu {entry}: {e}")
        import traceback
        traceback.print_exc()
        return f"Błąd podczas przetwarzania wpisu {entry}: {e}"


def main():
    """
    Główna funkcja skryptu.
    Obsługuje logowanie do Panoramy, pobieranie danych, wybór trybu wejścia
    i przetwarzanie wpisów hostów.
    """
    print("Skrypt weryfikacji hostów w Palo Alto Panorama")
    print("==============================================")
    
    # Domyślny adres Panoramy
    panorama_ip = "10.10.10.25"  # Zaszyte w kodzie
    
    # Pobierz dane logowania
    print(f"Adres IP Panoramy: {panorama_ip} [domyślny]")
    custom_ip = input("Podaj inny adres lub naciśnij Enter, aby użyć domyślnego: ")
    if custom_ip.strip():
        panorama_ip = custom_ip
    
    username = input("Podaj nazwę użytkownika: ")
    password = getpass.getpass("Podaj hasło: ")
    
    # Inicjalizacja API
    panorama = PanoramaAPI(panorama_ip, username, password)
    
    print("\nŁączenie z Panoramą...")
    if not panorama.get_api_key():
        print("Nie udało się uzyskać klucza API. Sprawdź dane logowania.")
        sys.exit(1)
    
    print("Pobieranie danych z Panoramy...")
    address_xml = panorama.get_address_objects()
    groups_xml = panorama.get_address_groups()
    
    # Parsowanie danych
    address_objects = parse_address_objects(address_xml)
    address_groups = parse_address_groups(groups_xml)
    
    if not address_objects and not address_groups:
        print("BŁĄD: Nie udało się pobrać ani obiektów, ani grup. Sprawdź połączenie i uprawnienia.")
        sys.exit(1)
    elif not address_objects:
        print("OSTRZEŻENIE: Nie udało się pobrać obiektów adresowych, ale pobrano grupy. Kontynuuję z ograniczoną funkcjonalnością.")
    elif not address_groups:
        print("OSTRZEŻENIE: Nie udało się pobrać grup adresowych, ale pobrano obiekty. Kontynuuję z ograniczoną funkcjonalnością.")
    
    print(f"Pobrano {len(address_objects)} obiektów adresowych i {len(address_groups)} grup.")
    
    # Wybór źródła wejściowego
    print("\nWybierz źródło danych wejściowych:")
    print("1. Plik tekstowy")
    print("2. Ręczne wprowadzanie wpisów")
    choice = input("Wybór (1/2): ")
    
    if choice == "1":
        # Wczytaj dane z pliku
        file_path = input("Podaj ścieżkę do pliku: ")
        try:
            with open(file_path, 'r') as file:
                entries = file.readlines()
        except Exception as e:
            print(f"Błąd podczas wczytywania pliku: {e}")
            sys.exit(1)
    else:
        # Ręczne wprowadzanie
        print("\nWprowadź wpisy w formacie 'nazwahosta-grupa IP'.")
        print("Wprowadź pustą linię, aby zakończyć.")
        
        entries = []
        while True:
            entry = input("> ")
            if not entry.strip():
                break
            entries.append(entry)
    
    # Znajdź unikalne prefiksy grup
    unique_prefixes = find_unique_group_prefixes(entries)
    
    if not unique_prefixes:
        print("BŁĄD: Nie znaleziono prefiksów grup w podanych wpisach.")
        sys.exit(1)
    
    print("\nZnaleziono następujące prefiksy grup:")
    for i, prefix in enumerate(unique_prefixes, 1):
        print(f"{i}. {prefix}")
    
    # Utwórz mapowanie prefiksów grup na rzeczywiste nazwy grup w Panoramie
    print("\nDostępne grupy adresowe w Panoramie:")
    group_names = list(address_groups.keys())
    for i, name in enumerate(group_names, 1):
        print(f"{i}. {name}")
    
    # Pobierz mapowanie od użytkownika
    group_mapping = {}
    print("\nPrzypisz prefiksy grup do rzeczywistych grup w Panoramie:")
    for prefix in unique_prefixes:
        while True:
            print(f"\nPrefiks: {prefix}")
            mapping = input(f"Podaj numer lub nazwę grupy z Panoramy dla prefiksu '{prefix}': ")
            
            # Sprawdź, czy podano numer grupy
            try:
                index = int(mapping)
                if 1 <= index <= len(group_names):
                    group_mapping[prefix] = group_names[index-1]
                    print(f"Przypisano prefiks '{prefix}' do grupy '{group_mapping[prefix]}'")
                    break
                else:
                    print(f"Błędny numer grupy. Podaj wartość od 1 do {len(group_names)}.")
            except ValueError:
                # Sprawdź, czy podana nazwa grupy istnieje
                if mapping in group_names:
                    group_mapping[prefix] = mapping
                    print(f"Przypisano prefiks '{prefix}' do grupy '{mapping}'")
                    break
                else:
                    print("Podana nazwa grupy nie istnieje w Panoramie. Spróbuj ponownie.")
    
    # Przetwórz wpisy
    print("\nWyniki weryfikacji:")
    print("===================")
    
    # Lista na wyniki do zapisania
    all_results = []
    direct_match_results = []  # Hosty bezpośrednio w grupie
    range_match_results = []   # Hosty w zakresie należącym do grupy
    no_match_results = []      # Hosty bez dopasowania do grupy
    
    # Przetwórz każdy wpis
    for entry in entries:
        if entry.strip():
            result = process_host_entry(entry, address_objects, address_groups, group_mapping)
            
            # Klasyfikuj wynik
            if " i znajduje się w grupie " in result:
                direct_match_results.append(result)
            elif ", nie jest bezpośrednio w grupie " in result and " ale mieści się w zakresie " in result:
                range_match_results.append(result)
            else:
                no_match_results.append(result)
    
    # Połącz wyniki w odpowiedniej kolejności
    print("\n--- Hosty bezpośrednio w grupie ---")
    for result in direct_match_results:
        print(result)
        all_results.append(result)
    
    print("\n--- Hosty w zakresie należącym do grupy ---")
    for result in range_match_results:
        print(result)
        all_results.append(result)
    
    print("\n--- Hosty bez dopasowania do grupy ---")
    for result in no_match_results:
        print(result)
        all_results.append(result)
    
    # Zapisz wyniki do pliku
    output_filename = "wyniki_weryfikacji.txt"
    
    # Bezpośredni zapis do pliku, bez dodatkowych funkcji
    try:
        print(f"\nZapisuję wyniki do pliku {output_filename}...")
        with open(output_filename, 'w', encoding='utf-8') as f:
            f.write("Wyniki weryfikacji hostów w Palo Alto Panorama\n")
            f.write("===========================================\n\n")
            
            f.write("--- Hosty bezpośrednio w grupie ---\n")
            for result in direct_match_results:
                f.write(str(result) + "\n")
            
            f.write("\n--- Hosty w zakresie należącym do grupy ---\n")
            for result in range_match_results:
                f.write(str(result) + "\n")
            
            f.write("\n--- Hosty bez dopasowania do grupy ---\n")
            for result in no_match_results:
                f.write(str(result) + "\n")
            
        print(f"Wyniki zostały zapisane do pliku: {output_filename}")
        
    except Exception as e:
        print(f"BŁĄD: Nie udało się zapisać wyników do pliku: {e}")
        print("Wyświetlam wszystkie wyniki na ekranie jeszcze raz do ręcznego skopiowania:")
        for i, result in enumerate(all_results, 1):
            print(f"{i}. {result}")


if __name__ == "__main__":
    main()
